ручка /api/user/register

ждёт :

email (есть валидация)
password (есть валидация , более 6 символов  - user.register.route.js строка 9 )

отдаёт (объект с полями):

id
email
isActivated (тут будет фолс после регистрации)
refreshToken (этот токен попадёт в куки под названием 'refreshToken')
accessToken (а вот этот токен нужно вшивать в тело запросов чтобы сервер понимал , что обращается авторизованый)
message: `пользователь с email = ${email} зарегистрирован`
___________________________________________________________________________________________________

ручка /api/user/login

ждёт :

email
password

отдаёт (объект с полями. валидация по полю isActivated user.login.route.js строка 17):

id
email
isActivated
refreshToken
accessToken
message: `Успешный вход пользователя с email = ${email}`
___________________________________________________________________________________________________

ручка /api/user/refresh

ждёт :

refreshToken в куках

отдаёт (объект с полями):

id
email
isActivated
refreshToken
accessToken
message: `токены для пользователя с email = ${userToRefresh.email} обновлены`

Нафига рефреш лезет в базу и отдаёт айди , емейл и активирован ? Нуу потому что за время жизни рефреш токена пользователю могли поменять почту или поставить статус не активирован и тд.
___________________________________________________________________________________________________

ручка /api/user/activate/:link

ждёт :

строку в req.params

отдаёт :

редирект на FRONT_URL:FRONT_PORT
___________________________________________________________________________________________________

ручка /api/user/logout

ждёт :

refreshToken в куках

отдаёт (объект с полями):

message: `Выход пользователя с email = ${userToLogout.email}`
___________________________________________________________________________________________________

ручка /api/user/getall Для примера !

ждёт :

isActivated = true в req.user

отдаёт (массив объектов):

пользователи

В этой ручке используется мидлвара authCheck.js . При обращении к /api/user/getall GET сначала отработает мидлвара ,
которая ждёт в req.headers.authorization access токен. Если с токеном всё хорошо , то в req.user кладётся то , что вшито в токен
(в нашем случе это id , email , isActivated) и это можно использовать в ручке (isActivated как минимум).
Эту мидлвару надо везде приделывать.

